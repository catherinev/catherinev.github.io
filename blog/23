<!DOCTYPE html>
<html>
  <head>
    <title>Catheine V</title>
    <link data-turbolinks-track="true" href="/assets/reset.css?body=1" media="all" rel="stylesheet" />
<link data-turbolinks-track="true" href="/assets/style.css?body=1" media="all" rel="stylesheet" />
<link data-turbolinks-track="true" href="/assets/application.css?body=1" media="all" rel="stylesheet" />
    <link href='http://fonts.googleapis.com/css?family=Gafata' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto:300italic,300,500' rel='stylesheet' type='text/css'>
  </head>

  <body>
    <h1>Catherine Vongsathorn</h1>
    <script src="/assets/jquery.js?body=1"></script>
<script src="/assets/jquery_ujs.js?body=1"></script>
<script src="/assets/turbolinks.js?body=1"></script>
<script src="/assets/highlightNav.js?body=1"></script>
<script src="/assets/application.js?body=1"></script>
<div class = "nav">
  <button id = "menu-icon">menu</button>
  <div><a href="/">Home</a></div>
  <div><a href="/about.html">About</a></div>
  <div><a href="/blog.html">Blog</a></div>
  <div><a href="/experience.html">Experience</a></div>
  <div><a href="/links.html">Links</a></div>
</div>
    
    <h2>Sunday, May 4, 2014</h2>
<div class = "post">
  <h3>Sorting</h3>
  <p>Sorting is the ability to take a list (e.g., array, hash) and put the elements in order.  While it is a simple concept, there are many different ways to go about doing it.  If you were asked to manually order a list of randomly generated numbers, how would you do it?  Perhaps you'd consider doing something like this:</p>
			<ol>
				<li>Look at the first number.  Since it's first, it is the smallest number so far.  Remember this number and move to the next number in your list.</li>
				<li>Is this number smaller than the number you have remembered?  If so, this number is now the smallest; forget the number that used to be smallest and remember this number instead.  Otherwise, just keep going.</li>
				<li>Move to the next element in your list and repeat step 2. Continue until you reach the end of the list.  By this time, you will have found the smallest number in your list.</li>
				<li>Take the smallest number out of the list and add it to a new, ordered list.</li>
				<li>Repeat steps 1-4 until your unordered list is empty.</li>
			</ol>
			<p>This will certainly work, but it's <em>really inefficient</em>.  For each number in your list, you have to go through the entire (remaining) list and then add it to the new list.  Let's say you have a list of 10 numbers and it takes you 1 second to look at each element in the list (and decide if you should "remember" it).  Then, this algorithm will take you 10 seconds to find the smallest number, 9 seconds to find the next smallest, 8 seconds to find the next...for a total of 10+9+8+7+6+5+4+3+2+1 = 55 seconds to put that list in order.  (Note: this assumes that step 4 takes 0 seconds.)</p>

			<p>But what if your list has 100 elements in it?  Then it will take you 100+99+98+...+2+1 = 5050 seconds to order this list!  If this doesn't upset you, it should: we multiplied the number of elements in our list by 10, but it took almost 100 times as long to run the algorithm.  This is bad.  It's slow.  Even if the list is already in order, the algorithm will take 5050 seconds to verify the order of a list with 100 elements. Surely we can do better.</p>

			<h4>Bubble Sort</h4>
			<p>Of the sorting algorithms we will look at, bubble sort is perhaps the easiest to understand:</p>
			<ol>
				<li>Look at first two elements.  Swap if they aren't ordered properly.</li>
				<li>Look at the next two elements.  Swap if they aren't ordered properly.</li>
				<li>Continue until the end of the list.</li>
				<li>Go back to the beginning of the list and repeat steps 1-3.</li>
				<li>Repeat step 4 until steps 1-3 do not result in any swaps.  This means the list is in order.</li>
			</ol>
			<p>This is not particularly efficient, but it's still better than our very first example: at least if the list is already in order, it won't take very much time.</p>

			<h4>Merge Sort</h4>
			<p>Merge sort takes advantage of the following: <b>combining two lists that are already sorted is not that hard</b>.  To see why this is indeed true, let's look at an example.</p>
			<p>Suppose we are trying to combine the following two (already sorted) lists into one sorted list.</p>
			<ul>
				<li>List 1: 2, 7, 22, 39</li>
				<li>List 2: 0, 9, 16, 20, 47</li>
			</ul>
			<p>Let's start by finding the smallest element across both lists.  In order to do this, we need only compare the smallest element in each list, 2 and 0.  When we do this, we see that 0 < 2.  But why is this one comparison sufficient to determine that 0 is less than <em>all</em> the elements in Lists 1 and 2?  Because of the following two facts:</p>
			<p class = "indent">Fact 1: 0 is less than all the elements in List 2 (because List 2 is in order).</p>
			<p class = "indent">Fact 2: 0 < 2 and 2 is less than all the elements in List 1.  Thus, 0 is less than all the elements in List 1.</p>
			<p>Now that we have determined that 0 is the smallest element, we remove it from List 1 and repeat the process of finding the smallest element by the same process as before: comparing the two smallest elements in the remaining lists.</p>
			<ul>
				<li>List 1: 2, 7, 22, 39</li>
				<li>List 2: 9, 16, 20, 47</li>
				<li>Sorted List (so far): 0</li>
			</ul>
			<p>Since 2 < 9, we move it from List 1 to our Sorted List.  Then repeat.</p>
			<ul>
				<li>List 1: 7, 22, 39</li>
				<li>List 2: 9, 16, 20, 47</li>
				<li>Sorted List (so far): 0, 2</li>
			</ul>
			<p>Since 7 < 9, we move 7 from List 1 to the Sorted List.  Then repeat.</p>
			<ul>
				<li>List 1: 22, 39</li>
				<li>List 2: 9, 16, 20, 47</li>
				<li>Sorted List (so far): 0, 2, 7</li>
			</ul>
			<p>We continue the process of comparing the smallest elements in each list until our Sorted List is complete and no elements remain in the original two lists.  In our example, we eventually get a Sorted List of 0, 2, 7, 9, 16, 20, 22, 39, 47.</p>

			<p>Merge sort take advantage of the fact that it's easy to combine lists that are already sorted by using the following algorithm to sort.</p>
			<ol>
				<li>Split the list you want to sort in to sublists that each contain at most two elements.<br/>
				</li>
				<li>For each sublist of two, switch the order if the second is smaller than the first.  This has the effect of ordering each of the sublists.<br/>
				</li>
				<li>Combine the sublists of two into sublists of four (until it isn't possible to make any more sublists of four):</li>
				<li>Combine the sublists of four into sublists of eight (until it isn't possible to make any more sublists of eight).</li>
				<li>Continue until all lists have been combined into one.</li>
			</ol>
			<p>Merge sorting is a pretty efficient way to sort lists (even pretty large ones) and is the default sort algorithm in many languages.</p>

			<h4>Quick Sort</h4>
			<p>Quick sort orders one element at a time.  Again, let's consider an example.  Suppose we'd like to order the list 2, 16, 7, 22, 39, 0.  We start by picking an element, perhaps 2.  When we compare each of the other elements to 2, we see that all elements are great than 2 except for 0.  Therefore, we move the 0 so that it is less than 2 and keep the order of the rest of the elements as is.</p>
			<p class = "indent">0, 2, 16, 7, 22, 39</p>
			<p>Now, 2 is in the right place.  This means we only need to order the elements that are less than 2 and those that are greater than 2 (separately).  Since 0 is the only number less than 2, we're done with "that side".  To sort the "other side", let's pick another element, say 16, and do the repeat procedure we used to get 2 in the right place.  Since 7 is less than 16 (and we already determined that 7 is greater than 2), this has the affect of moving the 7 between 2 and 16:</p>
			<p class = "indent">0, 2, 7, 16, 22, 39</p>
			<p>We continue checking elements until we are sure everything is in the right place.  In this case, everything is already in the right place, so we are done.</p>
			<p>Quicksort is pretty good, but it's possible to "get unlucky" and have the algorithm take a while.  Our example list got sorted pretty quickly (few steps), but what if we had instead started with 39, 22, 16, 7, 2, 0?  This is the same list in a different order, and it could take many more steps to implement the quicksort algorithm:</p>
			<p class = "indent">39,&nbsp;22,&nbsp;16,&nbsp;7,&nbsp;2,&nbsp;0 &#8594; 0,&nbsp;2,&nbsp;39,&nbsp;22,&nbsp;16,&nbsp;7 &#8594; 0,&nbsp;2,&nbsp;22,&nbsp;16,&nbsp;7,&nbsp;39 &#8594; 0,&nbsp;2,&nbsp;16,&nbsp;7,&nbsp;22,&nbsp;39 &#8594; 0,&nbsp;2,&nbsp;7,&nbsp;16,&nbsp;22,&nbsp;39 </p>

		
			<h4>A final note</h4>
			<p>All these examples are done with numbers, but any type of elements can be sorted with these algorithms as long as there is a way to <em>compare</em> them.  For example, it makes sense to say that "a" < "b" (and similarly for other elements in the alphabet), so we can apply the same sorting algorithms to strings.</p>
		
</div>


    <footer>
  <div id = "left">Contact me: <a href="mailto:cvong47@gmail.com">Email</a></div>
  <div id = "right">&copy;2014 Catherine Vongsathorn</div>
</footer>

  </body>
</html>
